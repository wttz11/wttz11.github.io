<!doctype html><html lang="en-US"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="generator" content="VuePress 2.0.0-rc.8" /><meta name="theme" content="VuePress Theme Plume 1.0.0-rc.39" /><script id="check-dark-mode">;(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;if (um === 'dark' || (um !== 'light' && sm)) {document.documentElement.classList.add('dark');}})();</script><script id="check-mac-os">document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))</script><link rel="icon" href="/images/head-circle.jpg"><title>Vue3的响应式系统</title><meta name="description" content=""><link rel="preload" href="/assets/style-BzznhLG_.css" as="style"><link rel="stylesheet" href="/assets/style-BzznhLG_.css"><link rel="modulepreload" href="/assets/app-CVXxSXU1.js"><link rel="modulepreload" href="/assets/index.html-Dlz4L_BB.js"><link rel="prefetch" href="/assets/index.html-IO3j29SP.js" as="script"><link rel="prefetch" href="/assets/index.html-CoqXvvC7.js" as="script"><link rel="prefetch" href="/assets/index.html-CWcr5AlW.js" as="script"><link rel="prefetch" href="/assets/index.html-Czf7Vnis.js" as="script"><link rel="prefetch" href="/assets/index.html-C1FGj7z_.js" as="script"><link rel="prefetch" href="/assets/404.html-BzdO68uZ.js" as="script"><link rel="prefetch" href="/assets/index.html-DGTl63_I.js" as="script"><link rel="prefetch" href="/assets/index.html-BdbaKk5-.js" as="script"><link rel="prefetch" href="/assets/index.html-Bx7lDHR0.js" as="script"></head><body><div id="app"><!--[--><div class="theme-plume" data-v-ccde5b38><!--[--><!--[--><span tabindex="-1" data-v-ab0f771b></span><a href="#LayoutContent" class="skip-link visually-hidden" data-v-ab0f771b> Skip to content </a><!--]--><!----><div class="nav-wrapper" data-v-ccde5b38 data-v-4aa7bc5a><div class="navbar-wrapper" data-v-4aa7bc5a data-v-f397576e><div class="container" data-v-f397576e><div class="title" data-v-f397576e><div class="navbar-title" data-v-f397576e data-v-8c9bd93f><a class="auto-link link title" href="/" data-v-8c9bd93f data-v-92ad409b><!--[--><!----> <!--]--><!----></a></div></div><div class="content" data-v-f397576e><div class="curtain" data-v-f397576e></div><div class="content-body" data-v-f397576e><div class="navbar-search search" data-v-f397576e><!----></div><nav aria-labelledby="main-nav-aria-label" class="navbar-menu menu" data-v-f397576e data-v-a3f1a60e><span id="main-nav-aria-label" class="visually-hidden" data-v-a3f1a60e>Main Navigation</span><!--[--><!--[--><a class="auto-link link navbar-menu-link" href="/" data-v-a3f1a60e data-v-2867d7e1 data-v-92ad409b><!--[--><!----><i data-v-2867d7e1>Home</i><!--]--><!----></a><!--]--><!--[--><a class="auto-link link navbar-menu-link" href="/blog/" data-v-a3f1a60e data-v-2867d7e1 data-v-92ad409b><!--[--><!----><i data-v-2867d7e1>Blog</i><!--]--><!----></a><!--]--><!--]--></nav><!----><div class="navbar-appearance appearance" data-v-f397576e data-v-2e93bdf2><button class="switch-wrapper switch-appearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-2e93bdf2 data-v-44f1284c data-v-bca38222><span class="check" data-v-bca38222><span class="icon" data-v-bca38222><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-44f1284c><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-44f1284c><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><!----><div class="flyout-wrapper navbar-extra extra" data-v-f397576e data-v-82afdbbd data-v-3a9d871b><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-3a9d871b><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-3a9d871b><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-3a9d871b><div class="menu-wrapper" data-v-3a9d871b data-v-a471995b><!----><!--[--><!--[--><!----><div class="group" data-v-82afdbbd><div class="item appearance" data-v-82afdbbd><p class="label" data-v-82afdbbd>Appearance</p><div class="appearance-action" data-v-82afdbbd><button class="switch-wrapper switch-appearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-82afdbbd data-v-44f1284c data-v-bca38222><span class="check" data-v-bca38222><span class="icon" data-v-bca38222><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-44f1284c><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-44f1284c><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><!----><!--]--><!--]--></div></div></div><button type="button" class="navbar-hamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="nav-screen" data-v-f397576e data-v-1925941b><span class="container" data-v-1925941b><span class="top" data-v-1925941b></span><span class="middle" data-v-1925941b></span><span class="bottom" data-v-1925941b></span></span></button></div></div></div></div><!----></div><div class="local-nav reached-top is-blog" data-v-ccde5b38 data-v-9e97fa1e><button class="hidden menu" disabled aria-expanded="false" aria-controls="SidebarNav" data-v-9e97fa1e><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-9e97fa1e><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-9e97fa1e>Menu</span></button><div class="local-nav-outline-dropdown" style="--vp-vh:0px;" data-v-9e97fa1e data-v-0c2ee5ba><button class="" data-v-0c2ee5ba>On this page <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-0c2ee5ba><path d="M9,19c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l5.3-5.3L8.3,6.7c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l6,6c0.4,0.4,0.4,1,0,1.4l-6,6C9.5,18.9,9.3,19,9,19z" fill="currentColor"></path></svg></button><!----></div></div><!----><div id="LayoutContent" class="layout-content" data-v-ccde5b38 data-v-15e802b3><!--[--><div class="plume-page has-aside is-blog" data-v-ccde5b38 data-v-6df22fc2><div class="container" data-v-6df22fc2><div class="aside" data-v-6df22fc2><div class="aside-container" data-v-6df22fc2><div class="aside-content" data-v-6df22fc2><div class="page-aside" data-v-6df22fc2 data-v-7a77d7d2><div class="has-outline page-aside-outline" data-v-7a77d7d2><div class="content" data-v-7a77d7d2><div class="outline-marker" data-v-7a77d7d2></div><div class="outline-title" data-v-7a77d7d2><span data-v-7a77d7d2>On this page</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="icon" data-v-7a77d7d2><path fill="currentColor" d="M16 8V5H8v3H6V3h12v5zM4 10h16zm14 2.5q.425 0 .713-.288T19 11.5q0-.425-.288-.712T18 10.5q-.425 0-.712.288T17 11.5q0 .425.288.713T18 12.5M16 19v-4H8v4zm2 2H6v-4H2v-6q0-1.275.875-2.137T5 8h14q1.275 0 2.138.863T22 11v6h-4zm2-6v-4q0-.425-.288-.712T19 10H5q-.425 0-.712.288T4 11v4h2v-2h12v2z"></path></svg></div><nav aria-labelledby="doc-outline-aria-label" data-v-7a77d7d2><span id="doc-outline-aria-label" class="visually-hidden" data-v-7a77d7d2> Table of Contents for current page </span><ul class="root" data-v-7a77d7d2 data-v-784c5b47><!--[--><li data-v-784c5b47><a class="outline-link" href="#副作用函数-1" data-v-784c5b47>副作用函数</a><ul class="nested" data-v-784c5b47 data-v-784c5b47><!--[--><li data-v-784c5b47><a class="outline-link" href="#effect-函数包装副作用函数" data-v-784c5b47>effect()函数包装副作用函数</a><!----></li><li data-v-784c5b47><a class="outline-link" href="#computed-的实现" data-v-784c5b47>computed()的实现</a><!----></li><li data-v-784c5b47><a class="outline-link" href="#任务队列" data-v-784c5b47>任务队列</a><!----></li><li data-v-784c5b47><a class="outline-link" href="#watch-的实现" data-v-784c5b47>watch()的实现</a><!----></li><!--]--></ul></li><li data-v-784c5b47><a class="outline-link" href="#响应式数据-1" data-v-784c5b47>响应式数据</a><ul class="nested" data-v-784c5b47 data-v-784c5b47><!--[--><li data-v-784c5b47><a class="outline-link" href="#track-与trigger" data-v-784c5b47>track()与trigger()</a><!----></li><li data-v-784c5b47><a class="outline-link" href="#reactive对象的创建" data-v-784c5b47>reactive对象的创建</a><!----></li><!--]--></ul></li><!--]--></ul></nav></div></div></div></div></div></div><div class="content" data-v-6df22fc2><div class="content-container" data-v-6df22fc2><main class="main" data-v-6df22fc2><!--[--><div class="page-category-wrapper" data-v-97c7dff6><!--[--><!--[--><span class="category" data-v-97c7dff6>前端</span><span class="dot" data-v-97c7dff6>›</span><!--]--><!--[--><span class="category" data-v-97c7dff6>Vue框架</span><span class="dot" data-v-97c7dff6>›</span><!--]--><!--[--><span class="category" data-v-97c7dff6>响应式</span><!----><!--]--><!--]--></div><h1 class="page-title" data-v-97c7dff6>Vue3的响应式系统</h1><div class="page-meta-wrapper" data-v-97c7dff6><p class="reading-time" data-v-97c7dff6><svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewbox="0 0 512 512" class="icon" data-v-97c7dff6><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="32" d="M256 160c16-63.16 76.43-95.41 208-96a15.94 15.94 0 0 1 16 16v288a16 16 0 0 1-16 16c-128 0-177.45 25.81-208 64c-30.37-38-80-64-208-64c-9.88 0-16-8.05-16-17.93V80a15.94 15.94 0 0 1 16-16c131.57.59 192 32.84 208 96m0 0v288"></path></svg><span data-v-97c7dff6>About 2624 words</span><span data-v-97c7dff6>About 9 min</span></p><p data-v-97c7dff6><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 20 20" class="icon" data-v-97c7dff6><g fill="currentColor"><path fill-rule="evenodd" clip-rule="evenodd" d="M17.707 9.293a1 1 0 010 1.414l-7 7a1 1 0 01-1.414 0l-7-7A.997.997 0 012 10V5a3 3 0 013-3h5c.256 0 .512.098.707.293l7 7zM5 6a1 1 0 100-2 1 1 0 000 2z"></path></g></svg><!--[--><span class="tag" style="--vp-tag-color:#946300;--vp-tag-bg-color:rgba(234, 179, 8, 0.14);" data-v-97c7dff6>Vue</span><!--]--></p><p class="create-time" data-v-97c7dff6><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon" data-v-97c7dff6><path fill="currentColor" d="M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"></path></svg><span data-v-97c7dff6>2024-01-3</span></p></div><!--]--><!--[--><div class="plume-content" data-v-6df22fc2><p>以下内容均围绕Vue3</p><p>响应式系统的核心其实就是<strong>响应式数据</strong>以及其对应的<strong>副作用函数</strong>，二者缺一都无法实现响应式</p><h1 id="副作用函数" tabindex="-1"><a class="header-anchor" href="#副作用函数"><span>副作用函数</span></a></h1><p>副作用函数是指那些运行会对页面或者其他数据产生影响的函数，而并非一个纯函数。通常渲染函数，<code>computed</code>、<code>watch</code>、<code>watchEffect</code>中所配置的函数等等都是副作用函数</p><h1 id="响应式数据" tabindex="-1"><a class="header-anchor" href="#响应式数据"><span>响应式数据</span></a></h1><p>响应式数据是指发生变化后需要引起页面变化或其他数据变化的那些数据，通常以<code>ref</code>,<code>reactive</code>所声明的数据，以及<code>computed</code>、<code>watch</code>、<code>watcheffect</code>所使用的数据均为响应式数据</p><h1 id="响应式原理" tabindex="-1"><a class="header-anchor" href="#响应式原理"><span>响应式原理</span></a></h1><p>响应式的原理其实很简单也容易理解，收集所有响应式数据相关的副作用函数，在响应式数据发生变化时把他们都重执行一次即可</p><p><img src="/assets/响应式流程-CaS_koEg.png" alt=""></p><h1 id="具体实现" tabindex="-1"><a class="header-anchor" href="#具体实现"><span>具体实现</span></a></h1><h2 id="副作用函数-1" tabindex="-1"><a class="header-anchor" href="#副作用函数-1"><span>副作用函数</span></a></h2><h3 id="effect-函数包装副作用函数" tabindex="-1"><a class="header-anchor" href="#effect-函数包装副作用函数"><span><code>effect()</code>函数包装副作用函数</span></a></h3><p>真正被存放与取出使用的函数是经过<code>effect()</code>包装的</p><p><strong><code>effect()</code>函数的基本实现</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" v-pre=""><code><span class="line"><span></span></span>
<span class="line"><span>function effect(fn, options={}){</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    const effectFn = () =&gt;{</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        //清除原有的响应式依赖关系，主要针对函数中存在分支切换的情况，下面执行fn的过程中会更新依赖关系</span></span>
<span class="line"><span>        cleanup(effectFn)   </span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // activeEffect是一个全局变量，保存正在运行的副作用，用于副作用函数的收集</span></span>
<span class="line"><span>        activeEffect =effectFn  </span></span>
<span class="line"><span></span></span>
<span class="line"><span>        /*effectStack栈同样是一个全局变量，与下方的当前副作用函数的入栈出栈操作结合，</span></span>
<span class="line"><span>        用于解决发生副作用函数嵌套时的响应式丢失问题*/</span></span>
<span class="line"><span>        // 在调用副作用函数之前将当前副作用函数压栈</span></span>
<span class="line"><span>        effectStack.push(effectFn)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        //调用待封装的函数，函数执行时会触发响应式变量的get方法进行收集</span></span>
<span class="line"><span>        const res =fn()  </span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把activeEffect 还原为之前的值</span></span>
<span class="line"><span>        effectStack.pop()</span></span>
<span class="line"><span>        activeEffect=effectStack[effectStack.length-1]</span></span>
<span class="line"><span>        return res</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    effectFn.options=options    //配置项，可用于在trigger函数中调度器的执行</span></span>
<span class="line"><span>    effectFn.deps=[]    //为当前副作用函数创造依赖集合，存放那些含有当前副作用函数的set，用于cleanup</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if(!options.lazy){  //lazy选项，在计算属性和监听器中会用到</span></span>
<span class="line"><span>        effectFn()</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return effectFn()</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong><code>cleanup()</code>函数的基本实现</strong></p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" v-pre=""><code><span class="line"><span>function cleanup(effectFn){</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //遍历effectFn.deps,其中的元素是包含了该副作用函数的set</span></span>
<span class="line"><span>    for(let i=0;i&lt;effectFn.deps.length;i++){</span></span>
<span class="line"><span>        const deps =effectFn.deps[i] //即set</span></span>
<span class="line"><span>        deps.delete(effectFn)   //从set中删除当前函数</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    effectFn.deps.length=0</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>computed</code>,<code>watch</code>,<code>watchEffect</code>也都与effect的封装与调度器（与options参数相关）的使用相关</p><h3 id="computed-的实现" tabindex="-1"><a class="header-anchor" href="#computed-的实现"><span><code>computed()</code>的实现</span></a></h3><p><code>computed()</code> 方法期望接收一个 getter 函数，返回值为一个计算属性 ref。和其他一般的 ref 类似，你可以通过 obj.value 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 .value。Vue 的计算属性会自动追踪响应式依赖。(来自Vue3文档)</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" v-pre=""><code><span class="line"><span></span></span>
<span class="line"><span>function computed(getter) {</span></span>
<span class="line"><span>    let value</span></span>
<span class="line"><span>    let dirty = true</span></span>
<span class="line"><span>    const effectFn = effect(getter, {</span></span>
<span class="line"><span>        lazy: true,</span></span>
<span class="line"><span>        scheduler() {</span></span>
<span class="line"><span>            if (!dirty) {</span></span>
<span class="line"><span>                dirty = true</span></span>
<span class="line"><span>                // 当计算属性依赖的响应式数据变化时，手动调用 trigger 函数触发响应</span></span>
<span class="line"><span>                trigger(obj, &#39;value&#39;)</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>    const obj = {</span></span>
<span class="line"><span>        get value() {</span></span>
<span class="line"><span>            if (dirty) {</span></span>
<span class="line"><span>                value = effectFn()</span></span>
<span class="line"><span>                dirty = false</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            // 当读取 value 时，手动调用 track 函数进行追踪</span></span>
<span class="line"><span>            track(obj, &#39;value&#39;)</span></span>
<span class="line"><span>            return value</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return obj</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="getter-不应有副作用​" tabindex="-1"><a class="header-anchor" href="#getter-不应有副作用​"><span>getter 不应有副作用​</span></a></h4><p>计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。举例来说，不要改变其他状态、在 getter 中做异步请求或者更改 DOM！一个计算属性的声明中描述的是如何根据其他值派生一个值。因此 getter 的职责应该仅为计算和返回该值。在之后的指引中我们会讨论如何使用侦听器根据其他响应式状态的变更来创建副用。作</p><h4 id="避免直接修改计算属性值​" tabindex="-1"><a class="header-anchor" href="#避免直接修改计算属性值​"><span>避免直接修改计算属性值​</span></a></h4><p>从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。</p><h3 id="任务队列" tabindex="-1"><a class="header-anchor" href="#任务队列"><span>任务队列</span></a></h3><p>任务队列，个人理解就是为了在一个事件循环内，所有被触发渲染函数不是立即执行，而是收集起来进行去重优化后放入下一个微任务队列，可以提升渲染性能,在watch中也会使用</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" v-pre=""><code><span class="line"><span></span></span>
<span class="line"><span>// 定义一个任务队列，个人理解就是为了在一个事件循环内，所有被触发渲染函数不是立即执行，而是收集起来进行去重优化后放入下一个微任务队列，可以提升渲染性能</span></span>
<span class="line"><span>const jobQueue = new Set()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 使用 Promise.resolve() 创建一个 promise 实例，我们用它将一个任务添加到微任务队列</span></span>
<span class="line"><span>const p = Promise.resolve()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// 一个标志代表是否正在刷新队列</span></span>
<span class="line"><span>let isFlushing = false</span></span>
<span class="line"><span>function flushJob() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 如果队列正在刷新，则什么都不做</span></span>
<span class="line"><span>    if (isFlushing) return</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 设置为 true，代表正在刷新</span></span>
<span class="line"><span>    isFlushing = true</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 在微任务队列中刷新 jobQueue 队列</span></span>
<span class="line"><span>    p.then(() =&gt; {</span></span>
<span class="line"><span>        jobQueue.forEach(job =&gt; job())</span></span>
<span class="line"><span>    }).finally(() =&gt; {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 结束后重置 isFlushing</span></span>
<span class="line"><span>        isFlushing = false</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>effect(() =&gt; {</span></span>
<span class="line"><span>    console.log(obj.foo)</span></span>
<span class="line"><span>}, {</span></span>
<span class="line"><span>    scheduler(fn) {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 每次调度时，将副作用函数添加到 jobQueue 队列中</span></span>
<span class="line"><span>        jobQueue.add(fn)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 调用 flushJob 刷新队列</span></span>
<span class="line"><span>        flushJob()</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>})</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="watch-的实现" tabindex="-1"><a class="header-anchor" href="#watch-的实现"><span><code>watch()</code>的实现</span></a></h3><p>在组合式 API 中，我们可以使用 watch 函数在每次响应式状态发生变化时触发回调函数,watch 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" v-pre=""><code><span class="line"><span></span></span>
<span class="line"><span>//source 是响应式数据，cb 是回调函数，options是配置项</span></span>
<span class="line"><span>function watch(source, cb, options = {}) {</span></span>
<span class="line"><span>    let getter</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //如果传入的不是一个get函数，就将其包装为一个函数</span></span>
<span class="line"><span>    if (typeof source === &#39;function&#39;) {</span></span>
<span class="line"><span>        getter = source</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        getter = () =&gt; traverse(source)</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    let oldValue, newValue //用于存放新旧值</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // cleanup 用来存储用户注册的过期回调</span></span>
<span class="line"><span>    let cleanup</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 定义 onInvalidate 函数</span></span>
<span class="line"><span>    function onInvalidate(fn) {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 将过期回调存储到 cleanup 中</span></span>
<span class="line"><span>        cleanup = fn</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    const job = () =&gt; {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        //得到最新的响应式数据</span></span>
<span class="line"><span>        newValue = effectFn()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 在调用回调函数 cb 之前，先调用过期回调</span></span>
<span class="line"><span>        if (cleanup) {</span></span>
<span class="line"><span>            cleanup()</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 将 onInvalidate 作为回调函数的第三个参数，以便用户使用</span></span>
<span class="line"><span>        cb(newValue, oldValue, onInvalidate)</span></span>
<span class="line"><span>        oldValue = newValue</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    const effectFn = effect(</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 执行 getter，建立响应式联系</span></span>
<span class="line"><span>        () =&gt; getter(),</span></span>
<span class="line"><span>        {</span></span>
<span class="line"><span>            lazy: true,</span></span>
<span class="line"><span>            scheduler: () =&gt; {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                // 在调度函数中判断 flush 是否为 &#39;post&#39;，如果是，将其放到微任务队列中执行</span></span>
<span class="line"><span>                if (options.flush === &#39;post&#39;) {</span></span>
<span class="line"><span>                    const p = Promise.resolve()</span></span>
<span class="line"><span>                    p.then(job)</span></span>
<span class="line"><span>                } else {</span></span>
<span class="line"><span>                    job()</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>//是否立即执行一次，若立即执行则没有oldValue</span></span>
<span class="line"><span>    if (options.immediate) {</span></span>
<span class="line"><span>        job()</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        oldValue = effectFn()</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="响应式数据-1" tabindex="-1"><a class="header-anchor" href="#响应式数据-1"><span>响应式数据</span></a></h2><h3 id="track-与trigger" tabindex="-1"><a class="header-anchor" href="#track-与trigger"><span><code>track()</code>与<code>trigger()</code></span></a></h3><h4 id="track-用于副作用函数的收集" tabindex="-1"><a class="header-anchor" href="#track-用于副作用函数的收集"><span><code>track()</code>用于副作用函数的收集</span></a></h4><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" v-pre=""><code><span class="line"><span></span></span>
<span class="line"><span>function track(target, key) {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 没有 activeEffect，直接 return</span></span>
<span class="line"><span>    if (!activeEffect) return</span></span>
<span class="line"><span>    let depsMap = bucket.get(target)</span></span>
<span class="line"><span>    if (!depsMap) {</span></span>
<span class="line"><span>        bucket.set(target, (depsMap = new Map()))</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    let deps = depsMap.get(key)</span></span>
<span class="line"><span>    if (!deps) {</span></span>
<span class="line"><span>        depsMap.set(key, (deps = new Set()))</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 把当前激活的副作用函数添加到依赖集合 deps 中</span></span>
<span class="line"><span>    // deps 就是一个与当前副作用函数存在联系的依赖集合,就是一个Set</span></span>
<span class="line"><span>    deps.add(activeEffect)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 将其添加到 activeEffect.deps 数组中，存放那些包含当前副作用函数的的Set，用于cleanup</span></span>
<span class="line"><span>    activeEffect.deps.push(deps) // 新增</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="trigger-用于在数据变化时重执行响应式函数-这里地trigger仅用于object-对于array、map、set则要考虑它们自身属性的特殊性-类如array的length属性的响应式" tabindex="-1"><a class="header-anchor" href="#trigger-用于在数据变化时重执行响应式函数-这里地trigger仅用于object-对于array、map、set则要考虑它们自身属性的特殊性-类如array的length属性的响应式"><span><code>trigger()</code>用于在数据变化时重执行响应式函数(这里地trigger仅用于Object,对于Array、Map、Set则要考虑它们自身属性的特殊性，类如Array的length属性的响应式)</span></a></h4><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" v-pre=""><code><span class="line"><span></span></span>
<span class="line"><span>function trigger(target,key,type){</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //全局weakMap-&gt;Map-&gt;Set</span></span>
<span class="line"><span>    const depsMap= bucket.get(target)</span></span>
<span class="line"><span>    if(!depsMap) return</span></span>
<span class="line"><span>    const effects = depsMap.get(key)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    /*对原有Set做一个备份，因为之前说过，在执行副作用函数之前会进行cleanup操作，</span></span>
<span class="line"><span>    删去原有的响应依赖，而执行副作用函数又会收集依赖向Set中添加，倘若不做备份记录</span></span>
<span class="line"><span>    而直接遍历原Set去执行其中的副作用函数,会因为原Set不断地加入函数而陷入死循环*/</span></span>
<span class="line"><span>    const effectsToRun = new Set()</span></span>
<span class="line"><span>    effect &amp;&amp; effect.forEach((effectFn)=&gt;{</span></span>
<span class="line"><span>        if(effectFn !== activeEffect){</span></span>
<span class="line"><span>            effectsToRun.add(effectFn)</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 当操作类型为 ADD 或 DELETE 时，需要触发与 ITERATE_KEY 相关联的副作用函数重新执行</span></span>
<span class="line"><span>    if (type === &#39;ADD&#39; || type === &#39;DELETE&#39;) {</span></span>
<span class="line"><span>        const iterateEffects = depsMap.get(ITERATE_KEY)</span></span>
<span class="line"><span>        iterateEffects &amp;&amp; iterateEffects.forEach(effectFn =&gt; {</span></span>
<span class="line"><span>            if (effectFn !== activeEffect) {</span></span>
<span class="line"><span>                effectsToRun.add(effectFn)</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    //遍历备份Set执行副作用函数</span></span>
<span class="line"><span>    effectsToRun.forEach(effectFn =&gt; {</span></span>
<span class="line"><span>        //如果有调度器则直接执行调度器，在computed、watch属性中用到</span></span>
<span class="line"><span>        if (effectFn.options.scheduler) {</span></span>
<span class="line"><span>            effectFn.options.scheduler(effectFn)</span></span>
<span class="line"><span>        } else {</span></span>
<span class="line"><span>            effectFn()</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="reactive对象的创建" tabindex="-1"><a class="header-anchor" href="#reactive对象的创建"><span><code>reactive对象</code>的创建</span></a></h3><p>基本逻辑就是要在响应式数据被访问时调用<code>track()</code>进行依赖收集，在响应式数据被更改时调用<code>trigger()</code>进行依赖触发</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code" v-pre=""><code><span class="line"><span></span></span>
<span class="line"><span>function createReactive(obj, isShallow = false, isReadonly =false) {</span></span>
<span class="line"><span>    return new Proxy(obj, {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        /*使用Reflect是为了利用receiver参数保证在依赖收集，分发时保证this时刻指向代理对象，</span></span>
<span class="line"><span>        而不是原对象，只有对代理对象的操作才能产生响应式*/</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // 拦截读取操作</span></span>
<span class="line"><span>        get(target, key, receiver) {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            //可以通过raw属性访问到原对象</span></span>
<span class="line"><span>            if (key === &#39;raw&#39;) {</span></span>
<span class="line"><span>                return target</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            if (!isReadonly) {</span></span>
<span class="line"><span>                track(target, key)</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            const res = Reflect.get(target, key, receiver)</span></span>
<span class="line"><span>            if (isShallow) {</span></span>
<span class="line"><span>                return res</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            if (typeof res === &#39;object&#39; &amp;&amp; res !== null) {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                // 如果数据为只读，则调用 readonly 对值进行包装,否则递归调用reactive做深响应</span></span>
<span class="line"><span>                return isReadonly ? readonly(res) : reactive(res)</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            return res</span></span>
<span class="line"><span>        },</span></span>
<span class="line"><span>        set(target, key, newVal, receiver) {</span></span>
<span class="line"><span>            const oldVal = target[key]</span></span>
<span class="line"><span>            const type = Object.prototype.hasOwnProperty.call(target,key) ? &#39;SET&#39; : &#39;ADD&#39;</span></span>
<span class="line"><span>            const res = Reflect.set(target, key, newVal, receiver)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            /* 当使用get时，若当前对象上并没有这个属性则会去原型上寻找，倘若原型也是一个响应式对象</span></span>
<span class="line"><span>            则会导致原型与当前对象都与副作用函数建立响应式依赖，在响应式分发时也会在原型与当前对象上</span></span>
<span class="line"><span>            都执行一次副作用函数，  </span></span>
<span class="line"><span>            target === receiver.raw </span></span>
<span class="line"><span>            说明 receiver 就是 target 的代理对象，为了屏蔽因原型而引起的重复更新。*/</span></span>
<span class="line"><span>            if (target === receiver.raw) {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                // 比较新值与旧值，只有当它们不全等，并且不都是 NaN 的时候才触发响应</span></span>
<span class="line"><span>                if (oldVal !== newVal &amp;&amp; (oldVal === oldVal || newVal=== newVal)) {</span></span>
<span class="line"><span>                    trigger(target, key, type)</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>            return res</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>    //省略其他拦截函数</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><footer class="page-footer" data-v-6df22fc2 data-v-f65adbd3><!----><!----><nav class="prev-next" data-v-f65adbd3><div class="pager" data-v-f65adbd3><!----></div><div class="pager" data-v-f65adbd3><a class="auto-link link pager-link next" href="/article/eova9cfe/" data-v-f65adbd3 data-v-92ad409b><!--[--><span class="desc" data-v-f65adbd3>Next page</span><span class="title" data-v-f65adbd3>关于虚拟Dom</span><!--]--><!----></a></div></nav></footer><!----><!--]--></main></div></div></div></div><button style="display:none;" type="button" class="back-to-top-button" aria-label="back to top" data-v-ccde5b38 data-v-3a253c4a><span class="percent" data-v-3a253c4a>0%</span><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewbox="0 0 48 48" class="icon show" data-v-3a253c4a><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="4" d="M24.008 14.1V42M12 26l12-12l12 12M12 6h24"></path></svg><svg aria-hidden="true" data-v-3a253c4a><circle cx="50%" cy="50%" style="stroke-dasharray:calc(0% - 12.566370614359172px) calc(314.1592653589793% - 12.566370614359172px);" data-v-3a253c4a></circle></svg></button><footer class="plume-footer" data-v-ccde5b38 data-v-ebc9d2ec><div class="container" data-v-ebc9d2ec><p class="message" data-v-ebc9d2ec>Power by <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://github.com/pengzhanbo/vuepress-theme-plume">vuepress-theme-plume</a></p><!----></div></footer><!--]--></div><!--]--></div><!--[--><!--]--><!--]--></div><script type="module" src="/assets/app-CVXxSXU1.js" defer></script></body></html>